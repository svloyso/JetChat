## JetBot Documentation

Unfortunately, at this moment there is only Russian version of the documentation. English version is coming soon.

Данный документ представляет собой краткий обзор архитектуры и дизайна ботов. Он предназначен в основном для внутренего пользования и описывает не только API, но и детали реализации ботов, для удобства последюущего обслуживания и сопровождения кода.

### Общий дизайн

##### Как боты создаются в системе сервера? 
Центральным актором, отвечающим за регистрацию и управления ботами, является актор **BotManager**. Помимо регистрации ботов в его обязанности входит корректная передача сообщений от пользователей к ботам и обратно; выполнение запросов ботов (например, ID пользователя), и др.

Рассмотрми процесс создания бота чуть подробней:

 1. Пользователь пишет код своего бота и отправляет на сервер;
 2. Сервер передает этот код актору **BotManager**;
 3. **BotManager** в run-time компилирует этот код с помощью **BotBuilder**;
 4. Перед компиляцией код проходит стадию "рассахаривания" - в код добавляется некоторые конструкции, которые с логической точки зрения являются избыточными, но необходимы с точки зрения синтаксиса языка;
 5. Запускается метод launch, который создает непосредственно актора, который будет представлять из себя бота
 //TODO: поподробней описать этот момент, спросить у Славы
 
##### Внутреннее устройство ботов

Каждый бот предстваляет собой master-актор **BotActorImplementation**, с прикрепленными к нему slave-акторами **Talk**. Каждый **Talk** соответствует абстракции некоторой беседы бота с пользователем или группой пользователей. Такая абстрацкия позволяет легко получить параллельность бота и изолирует беседы друг от друга, что снижает сложность написания кода ботов.
**BotActorImplementation** занимается тем, что получает сообщения от **BotManager** и переадресовывает их нужному **Talk**, либо создает новый, если такового не имеется. Также **BotActorImplementation** пересылает сообщения от **Talk** к **BotManager**, который затем перешлет их в нужный топик.
Таким образом, важно понимать, что **Talk** _не общаются с пользователями напрямую_, а делают это исключительно через родительский **BotActorImplementation**

##### Talk

Каждый **Talk** является, по сути, детерминированным конечным автоматом (DFA, Finite State Machine, FSM). Таким образом, пользователем задается множество _состояний_, и каждому состоянию сопоставляется некоторое _поведение_, т.е. экземпляр класса **Behaviour**. **Behaviour** по сути представляет из себя обертку над функцией, которая будет применена к полученному сообщению. 
Отображение состояний на соответствующие им функции-обработчики хранится в mutable-Map _stateToHandlers\[String, Behaviour\]_
Также каждый **Talk** хранит внутри себя некоторые данные, разделяемые между состояняими, **но не между беседами**. Доступ к данным осуществляется через dynamic-поле **data**.  
 
Заметим, что в отличии от некоторых математических моделей, **Talk** может производить неограниченное количество операций вывода (отправки сообщения) или изменения данных за один переход между состояниями.

##### DSL implementation

DSL делится на две части - frontend, который будет доступен пользователю, и который будет предоставлять ему удобные и краткие методы и интерфейсы, и backend, который будет транслировать эти вызовы в вызовы к **BotManager**.

Frontend представляет из себя класс **Bot**, который будет скомпилирован **BotBuilder**'ом и который обладает методом **launch**, поднимающим актора бота. 
Также пользователю предоставляется для работы интерфейс **Behaviour**, который обладает рядом вспомогательных функций. Основным методом **Behaviour** является функция _handler_, которая будет применена к полученному сообщению.
Поскольку на момент написания пользовательского кода конкретный **Talk** не известен, то все эти функции абстрагированы по **Talk**. Вызов _handler_ на этом этапе приведет к ошибке времени исполнения. 
При фактическом создании **Talk** происходит _привязка_ **Behaviour** к конкретному экземпляру **Talk**, после чего все вспомогательные функции из **Behaviour** начинают просто пробрасывать вызов к этому экземляру.


### Создание ботов

Для удобства написания ботов в проекте используется Domain Specific Language. Рассмотрим простой пример создания бота, который сначла ждет, когда с ним поздороваются (ждет строку "hello"). После этого он переходит в эхо-состояние, и повторяет за пользователем все сообщения, добавляя к ним порядковый номер услышанного сообщения. Получив сообщение "bye", бот прощается и переходит в финальное состояние, в котором ничего не делает. //TODO: продумать завершение ботов

Сперва создадим объект типа **Bot**. Конструктор класса **Bot** принимает один параметр - имя бота.

```scala
val bot = new Bot("my-bot-name")
```
 
Теперь опишем данные, которые будет хранить наш бот. Сигнатура следующая `Bot.storesData[DataType](fieldName: String, DataType initialData)`. В дальнейшем можно будет обращаться к этому полю по имени **fieldName**.

```scala
bot.storesData[Int]("count", 0)
```

Теперь опишем состояния. Начнем с первого:

```scala
val startState = State("Start")(new Behaviour {
    override def handler(msg: TextMessage) = {
        msg.text match {
            case "hello" =>
                say("hello!")
                moveTo("Echo")
            case other =>
                say("Say hello to me first!")
        }
    }
})
```

Итак, мы создали объект класса State, который будет описывать одно из состояний, в котором может находиться **Talk** (см. выше). Мы дали этому состоянию название _Start_, а также передали анонимный класс, реализующий интерфейс **Behaviour** и перегружающий его метод _handler_.
При описании **Behaviour** можно использовать унаследованные от него методы **say** (отправить сообщение пользователю, с которым ведется разговор), **moveTo** (сменить состояние) и некоторые другие (см. описание API ниже)

Теперь опишем состояние, в котором бот будет повторять сообщения пользователя, попутно подсчитывая их:

```scala
val echoState = State("Echo")(new Behaviour {
    override def handler(msg: TextMessage) = {
        msg.text match {
            case "bye" =>
                say("Good bye :)")
                moveTo("Finish")
            case other =>
                data.count += 1
                say(msg.text + data.count.toString())
        }
    }
})
```

Обратите внимание, как происходит обращение к хранимым данным - по имени поля, указанном при вызове storesData. 

Наконец, заключительное состояние:
```scala
val finishState = State("Finish")(new Behaviour {
    override def handler(msg: TextMessage) = {
        msg.text match {
            case anything =>
                say("Talk is ended")
        }
    }
})
```


### API calls overview

#### Behaviour methods

##### say(text: String): Unit
Отправляет сообщение _text_ в текущий разговор

##### moveTo(nextState: String): Unit
Переводит **Talk** в состояние **nextState**. Кидает исключение _IllegalStateException_, если такого состояния не существует.

##### data: DynamicProxyStorage
Scala dynamic-объект. Поддерживает строго типизированное обращение к полям с синтакисом типа `data.someField`. Поля должны быть объявлены с помощью метода Bot.storesState


#### Bot methods

##### Bot(name: String): Bot
Конструктор объекта класса **Bot** с именем _name_

##### storesState[DataType](fieldName: String, DataType initialValue)
Регестрирует поле данных с именем _fieldName_ и типом _DataType_. Поле будет проинициализировано значением _DataType_. Тип поля должен быть сериализуем.

##### Bot.+(newState: State): Bot 
Добавляет боту состояние newState и возвращает this. Обратите внимание, что метод является модифицирующим - возвращаемое значение используется для удобной группировки (chaining) методов: `bot + oneState + anotherState + yetAnotherState`